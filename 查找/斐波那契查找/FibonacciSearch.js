/**
 * 什么是斐波那契查找
斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，
在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n>=2）。
该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。
斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。
在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，
将原查找表扩展为长度为F[n](如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素)，
完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。
 */

// 数组分割按斐波那契分割

// 二分查找 数组是折半分割

// 构建斐波那契数列
const fib = function () {
    // 而第20个斐波那契数是6765，所以这样的代码只能处理长度小于等于6765的数组。
    let maxSize = 20 // 默认数组最大为长度6765
    let f = new Array(maxSize)
    f[0] = 1
    f[1] = 1
    for (let i = 2; i < maxSize; i++) {
        f[i] = f[i - 1] + f[i - 2]
    }

    return f
}

// 二分查找 ===> 折半数组 计算mid  所以数组是以折半来分割（数组长度变化了） 再来计算对应的mid
// 所以斐波那契查找跟二分查找类型 ===>以斐波那契数列形式分割数组（数组长度变化了） 然后计算对应的mid k值的变化决定了数组的分割
// 斐波那契的数列的值表示该查找数组的长度
// 可以很精准的定位
const arr = [1, 2, 3, 4, 5, 6]
// 斐波那契数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）
// 斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的
// 斐波那契查找算法的明显优点在于它只涉及加法和减法运算，而不用除法。
// 因为除法比加减法要占去更多的机时，因此，斐波那契查找的平均性能要比折半查找好。
const FibonacciSearch = function (a, key) {
    let low = 0
    let high = a.length - 1
    let k = 0 // 表示斐波那契分割数组的下标
    let mid = 0
    let f = fib() // 需要借助一个斐波那契数列
    // 获取到斐波那契分割数组的下标
    while (high > f[k] - 1) {
        k++
    }
    // n=f[k]-1？ 为什么❓
    /**
     * 是为了格式上的统一，以方便递归或者循环程序的编写。
     * 表中的数据是F(k)-1个，使用mid值进行分割又用掉一个，那么剩下F(k)-2个。
     * 正好分给两个子序列，每个子序列的个数分别是F(k-1)-1与F(k-2)-1个，格式上与之前是统一的。不然的话，
     * 每个子序列的元素个数有可能是F(k-1)，F(k-1)-1，F(k-2)，F(k-2)-1个，写程序会非常麻烦。
     */
    let temp = new Array(f[k] - 1)
    for (let i = 0; i <= high; i++) {
        temp[i] = a[i]
    }
    for (let i = high + 1; i < f[k] - 1; i++) {
        temp[i] = a[high]
    }
    while (low <= high) {
        // low：起始位置  
        // 分割点mid 
        mid = low + f[k - 1] - 1 // 以斐波那契的形式分割数组===> 如何分割 找到找到这个分割点 ✅
        // 很重要的一点是我们如何分割数组的 包括二分查找 查找查找 是不是就是通过这个分割点就行分割数组的 所以明白这个很重要 就豁然开朗了 ❗️
        if (Object.is(mid, NaN)) {
            mid = 0
        }
        if (key < temp[mid]) {
            // 斐波那契数列左边
            high = mid - 1
            // 全部元素=前面的元素+后边的元素
            // 原来是这样确定数组前后的 数组长度为10 比如前面的长度为8 后面的为2
            // f[k]=f[k-1]+f[k-2]  斐波那契数列的特性 f[k]表示具体的值 也表示查找数列的长度
            // 因为前面我们有f[k-1] 我们可以继续拆分 f[k-1]=f[k-2]+f[k-3]
            // 即在f[k-1]的前面进行查找k-=1
            // 即下次循环mid=f[k-1-1]-1
            k--
        } else if (key > temp[mid]) {
            // 斐xx那契数列右边
            low = mid + 1
            // 后半部分是f[k-2]
            // 往后走就是k[k-2]=f[k-3]+f[k-4]
            // 即下次循环mid=f[k-1-2]-1
            // 所以k=k-2
            k -= 2
        } else {
            if (mid <= high) {
                return mid
            } else {
                //出现这种情况是查找到补充的元素
                //而补充的元素与high位置的元素一样
                return high
            }
        }
    }
    return -1
}

console.log(FibonacciSearch(arr, 3)) // 2


